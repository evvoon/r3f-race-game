System.register([],function(b){"use strict";return{execute:function(){b("createJSONStorage",_);const A=b("redux",(d,c)=>(a,s,o)=>(o.dispatch=e=>(a(v=>d(v,e),!1,e),e),o.dispatchFromDevtools=!0,{dispatch:(...e)=>o.dispatch(...e),...c})),I=new Map,w=d=>{const c=I.get(d);return c?Object.fromEntries(Object.entries(c.stores).map(([a,s])=>[a,s.getState()])):{}},T=(d,c,a)=>{if(d===void 0)return{type:"untracked",connection:c.connect(a)};const s=I.get(a.name);if(s)return{type:"tracked",store:d,...s};const o={connection:c.connect(a),stores:{}};return I.set(a.name,o),{type:"tracked",store:d,...o}},j=b("devtools",(d,c={})=>(a,s,o)=>{const{enabled:e,anonymousActionType:v,store:u,...p}=c;let g;try{g=(e!=null?e:!1)&&window.__REDUX_DEVTOOLS_EXTENSION__}catch{}if(!g)return d(a,s,o);const{connection:i,...f}=T(u,g,p);let h=!0;o.setState=(r,n,t)=>{const l=a(r,n);if(!h)return l;const S=t===void 0?{type:v||"anonymous"}:typeof t=="string"?{type:t}:t;return u===void 0?(i==null||i.send(S,s()),l):(i==null||i.send({...S,type:`${u}/${S.type}`},{...w(p.name),[u]:o.getState()}),l)};const m=(...r)=>{const n=h;h=!1,a(...r),h=n},y=d(o.setState,s,o);if(f.type==="untracked"?i==null||i.init(y):(f.stores[f.store]=o,i==null||i.init(Object.fromEntries(Object.entries(f.stores).map(([r,n])=>[r,r===f.store?y:n.getState()])))),o.dispatchFromDevtools&&typeof o.dispatch=="function"){const r=o.dispatch;o.dispatch=(...n)=>{r(...n)}}return i.subscribe(r=>{var n;switch(r.type){case"ACTION":if(typeof r.payload!="string"){console.error("[zustand devtools middleware] Unsupported action format");return}return E(r.payload,t=>{if(t.type==="__setState"){if(u===void 0){m(t.state);return}Object.keys(t.state).length!==1&&console.error(`
                    [zustand devtools middleware] Unsupported __setState action format. 
                    When using 'store' option in devtools(), the 'state' should have only one key, which is a value of 'store' that was passed in devtools(),
                    and value of this only key should be a state object. Example: { "type": "__setState", "state": { "abc123Store": { "foo": "bar" } } }
                    `);const l=t.state[u];if(l==null)return;JSON.stringify(o.getState())!==JSON.stringify(l)&&m(l);return}o.dispatchFromDevtools&&typeof o.dispatch=="function"&&o.dispatch(t)});case"DISPATCH":switch(r.payload.type){case"RESET":return m(y),u===void 0?i==null?void 0:i.init(o.getState()):i==null?void 0:i.init(w(p.name));case"COMMIT":if(u===void 0){i==null||i.init(o.getState());return}return i==null?void 0:i.init(w(p.name));case"ROLLBACK":return E(r.state,t=>{if(u===void 0){m(t),i==null||i.init(o.getState());return}m(t[u]),i==null||i.init(w(p.name))});case"JUMP_TO_STATE":case"JUMP_TO_ACTION":return E(r.state,t=>{if(u===void 0){m(t);return}JSON.stringify(o.getState())!==JSON.stringify(t[u])&&m(t[u])});case"IMPORT_STATE":{const{nextLiftedState:t}=r.payload,l=(n=t.computedStates.slice(-1)[0])==null?void 0:n.state;if(!l)return;m(u===void 0?l:l[u]),i==null||i.send(null,t);return}case"PAUSE_RECORDING":return h=!h}return}}),y}),E=(d,c)=>{let a;try{a=JSON.parse(d)}catch(s){console.error("[zustand devtools middleware] Could not parse the received json",s)}a!==void 0&&c(a)},R=b("subscribeWithSelector",d=>(c,a,s)=>{const o=s.subscribe;return s.subscribe=(e,v,u)=>{let p=e;if(v){const g=(u==null?void 0:u.equalityFn)||Object.is;let i=e(s.getState());p=f=>{const h=e(f);if(!g(i,h)){const m=i;v(i=h,m)}},u!=null&&u.fireImmediately&&v(i,i)}return o(p)},d(c,a,s)}),C=b("combine",(d,c)=>(...a)=>Object.assign({},d,c(...a)));function _(d){let c;try{c=d()}catch{return}return{getItem:a=>{var s;const o=v=>v===null?null:JSON.parse(v),e=(s=c.getItem(a))!=null?s:null;return e instanceof Promise?e.then(o):o(e)},setItem:(a,s)=>c.setItem(a,JSON.stringify(s)),removeItem:a=>c.removeItem(a)}}const O=d=>c=>{try{const a=d(c);return a instanceof Promise?a:{then(s){return O(s)(a)},catch(s){return this}}}catch(a){return{then(s){return this},catch(s){return O(s)(a)}}}},z=(d,c)=>(a,s,o)=>{let e={getStorage:()=>localStorage,serialize:JSON.stringify,deserialize:JSON.parse,partialize:n=>n,version:0,merge:(n,t)=>({...t,...n}),...c},v=!1;const u=new Set,p=new Set;let g;try{g=e.getStorage()}catch{}if(!g)return d((...n)=>{console.warn(`[zustand persist middleware] Unable to update item '${e.name}', the given storage is currently unavailable.`),a(...n)},s,o);const i=O(e.serialize),f=()=>{const n=e.partialize({...s()});let t;const l=i({state:n,version:e.version}).then(S=>g.setItem(e.name,S)).catch(S=>{t=S});if(t)throw t;return l},h=o.setState;o.setState=(n,t)=>{h(n,t),f()};const m=d((...n)=>{a(...n),f()},s,o);let y;const r=()=>{var n;if(!g)return;v=!1,u.forEach(l=>l(s()));const t=((n=e.onRehydrateStorage)==null?void 0:n.call(e,s()))||void 0;return O(g.getItem.bind(g))(e.name).then(l=>{if(l)return e.deserialize(l)}).then(l=>{if(l)if(typeof l.version=="number"&&l.version!==e.version){if(e.migrate)return e.migrate(l.state,l.version);console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return l.state}).then(l=>{var S;return y=e.merge(l,(S=s())!=null?S:m),a(y,!0),f()}).then(()=>{t==null||t(y,void 0),v=!0,p.forEach(l=>l(y))}).catch(l=>{t==null||t(void 0,l)})};return o.persist={setOptions:n=>{e={...e,...n},n.getStorage&&(g=n.getStorage())},clearStorage:()=>{g==null||g.removeItem(e.name)},getOptions:()=>e,rehydrate:()=>r(),hasHydrated:()=>v,onHydrate:n=>(u.add(n),()=>{u.delete(n)}),onFinishHydration:n=>(p.add(n),()=>{p.delete(n)})},r(),y||m},N=(d,c)=>(a,s,o)=>{let e={storage:_(()=>localStorage),partialize:r=>r,version:0,merge:(r,n)=>({...n,...r}),...c},v=!1;const u=new Set,p=new Set;let g=e.storage;if(!g)return d((...r)=>{console.warn(`[zustand persist middleware] Unable to update item '${e.name}', the given storage is currently unavailable.`),a(...r)},s,o);const i=()=>{const r=e.partialize({...s()});return g.setItem(e.name,{state:r,version:e.version})},f=o.setState;o.setState=(r,n)=>{f(r,n),i()};const h=d((...r)=>{a(...r),i()},s,o);let m;const y=()=>{var r;if(!g)return;v=!1,u.forEach(t=>t(s()));const n=((r=e.onRehydrateStorage)==null?void 0:r.call(e,s()))||void 0;return O(g.getItem.bind(g))(e.name).then(t=>{if(t)if(typeof t.version=="number"&&t.version!==e.version){if(e.migrate)return e.migrate(t.state,t.version);console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return t.state}).then(t=>{var l;return m=e.merge(t,(l=s())!=null?l:h),a(m,!0),i()}).then(()=>{n==null||n(m,void 0),v=!0,p.forEach(t=>t(m))}).catch(t=>{n==null||n(void 0,t)})};return o.persist={setOptions:r=>{e={...e,...r},r.storage&&(g=r.storage)},clearStorage:()=>{g==null||g.removeItem(e.name)},getOptions:()=>e,rehydrate:()=>y(),hasHydrated:()=>v,onHydrate:r=>(u.add(r),()=>{u.delete(r)}),onFinishHydration:r=>(p.add(r),()=>{p.delete(r)})},y(),m||h},k=b("persist",(d,c)=>"getStorage"in c||"serialize"in c||"deserialize"in c?(console.warn("[DEPRECATED] `getStorage`, `serialize` and `deserialize` options are deprecated. Please use `storage` option instead."),z(d,c)):N(d,c))}}});
